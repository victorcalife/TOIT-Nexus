const DatabaseService = require( './DatabaseService' );
const QuantumProcessor = require( './QuantumProcessor' );
const MilaService = require( './MilaService' );
const WorkflowNodes = require( './WorkflowNodes' );
const WorkflowConditionEngine = require( './WorkflowConditionEngine' );
const { db } = require( '../database-config' );

class WorkflowService
{
  constructor()
  {
    this.db = new DatabaseService();
    this.quantumProcessor = new QuantumProcessor();
    this.milaService = new MilaService();
    this.workflowNodes = new WorkflowNodes();
    this.conditionEngine = new WorkflowConditionEngine();

    // Tipos de n√≥s suportados (EXPANDIDO)
    this.nodeTypes = {
      // N√≥s b√°sicos
      'start': this.executeStartNode,
      'end': this.executeEndNode,
      'condition': this.executeConditionNode,
      'action': this.executeActionNode,
      'delay': this.executeDelayNode,

      // N√≥s de integra√ß√£o profissionais
      'execute_query': this.workflowNodes.executeQueryNode.bind( this.workflowNodes ),
      'create_task': this.workflowNodes.executeCreateTaskNode.bind( this.workflowNodes ),
      'send_email': this.workflowNodes.executeSendEmailNode.bind( this.workflowNodes ),
      'create_calendar_event': this.workflowNodes.executeCreateCalendarEventNode.bind( this.workflowNodes ),
      'generate_report': this.workflowNodes.executeGenerateReportNode.bind( this.workflowNodes ),
      'update_dashboard': this.workflowNodes.executeUpdateDashboardNode.bind( this.workflowNodes ),
      'mila_request': this.workflowNodes.executeMilaRequestNode.bind( this.workflowNodes ),
      'send_chat_message': this.workflowNodes.executeSendChatMessageNode.bind( this.workflowNodes ),

      // N√≥s legados (mantidos para compatibilidade)
      'email': this.executeEmailNode,
      'database': this.executeDatabaseNode,
      'api_call': this.executeApiCallNode,
      'quantum_process': this.executeQuantumProcessNode,
      'mila_analyze': this.executeMilaAnalyzeNode,
      'user_input': this.executeUserInputNode,
      'file_process': this.executeFileProcessNode,
      'notification': this.executeNotificationNode
    };
  }

  /**
   * Validar estrutura do workflow
   */
  async validateWorkflow( { nodes, edges } )
  {
    try
    {
      const errors = [];

      // Verificar se h√° pelo menos um n√≥ de in√≠cio
      const startNodes = nodes.filter( node => node.type === 'start' );
      if ( startNodes.length === 0 )
      {
        errors.push( 'Workflow deve ter pelo menos um n√≥ de in√≠cio' );
      }

      // Verificar se h√° pelo menos um n√≥ de fim
      const endNodes = nodes.filter( node => node.type === 'end' );
      if ( endNodes.length === 0 )
      {
        errors.push( 'Workflow deve ter pelo menos um n√≥ de fim' );
      }

      // Verificar se todos os n√≥s t√™m IDs √∫nicos
      const nodeIds = nodes.map( node => node.id );
      const uniqueIds = [ ...new Set( nodeIds ) ];
      if ( nodeIds.length !== uniqueIds.length )
      {
        errors.push( 'Todos os n√≥s devem ter IDs √∫nicos' );
      }

      // Verificar se todas as conex√µes s√£o v√°lidas
      edges.forEach( ( edge, index ) =>
      {
        const sourceExists = nodes.some( node => node.id === edge.source );
        const targetExists = nodes.some( node => node.id === edge.target );

        if ( !sourceExists )
        {
          errors.push( `Conex√£o ${ index + 1 }: n√≥ de origem '${ edge.source }' n√£o existe` );
        }

        if ( !targetExists )
        {
          errors.push( `Conex√£o ${ index + 1 }: n√≥ de destino '${ edge.target }' n√£o existe` );
        }
      } );

      // Verificar se h√° ciclos infinitos
      const hasCycles = this.detectCycles( nodes, edges );
      if ( hasCycles )
      {
        errors.push( 'Workflow cont√©m ciclos infinitos' );
      }

      // Verificar se todos os n√≥s s√£o alcan√ß√°veis
      const unreachableNodes = this.findUnreachableNodes( nodes, edges );
      if ( unreachableNodes.length > 0 )
      {
        errors.push( `N√≥s n√£o alcan√ß√°veis: ${ unreachableNodes.join( ', ' ) }` );
      }

      return {
        valid: errors.length === 0,
        errors
      };

    } catch ( error )
    {
      console.error( '‚ùå Erro na valida√ß√£o do workflow:', error );
      return {
        valid: false,
        errors: [ 'Erro na valida√ß√£o do workflow' ]
      };
    }
  }

  /**
   * Executar workflow
   */
  async executeWorkflow( { workflow, parameters = {}, dryRun = false, executionId, userId } )
  {
    try
    {
      console.log( `üîÑ Iniciando execu√ß√£o do workflow: ${ workflow.name }` );

      const context = {
        workflowId: workflow.id,
        executionId,
        userId,
        parameters,
        dryRun,
        variables: {},
        results: {},
        startTime: Date.now()
      };

      // Encontrar n√≥ de in√≠cio
      const startNodes = workflow.nodes.filter( node => node.type === 'start' );
      if ( startNodes.length === 0 )
      {
        throw new Error( 'Nenhum n√≥ de in√≠cio encontrado' );
      }

      // Executar a partir do primeiro n√≥ de in√≠cio
      const result = await this.executeNode( startNodes[ 0 ], workflow, context );

      const endTime = Date.now();
      const executionTime = ( endTime - context.startTime ) / 1000;

      console.log( `‚úÖ Workflow executado com sucesso em ${ executionTime }s` );

      return {
        success: true,
        result,
        context: {
          variables: context.variables,
          results: context.results,
          executionTime
        },
        dryRun
      };

    } catch ( error )
    {
      console.error( '‚ùå Erro na execu√ß√£o do workflow:', error );
      return {
        success: false,
        error: error.message,
        context: {
          variables: context?.variables || {},
          results: context?.results || {}
        },
        dryRun
      };
    }
  }

  /**
   * Executar n√≥ espec√≠fico
   */
  async executeNode( node, workflow, context )
  {
    try
    {
      console.log( `üîÑ Executando n√≥: ${ node.id } (${ node.type })` );

      // Verificar se o tipo de n√≥ √© suportado
      const executor = this.nodeTypes[ node.type ];
      if ( !executor )
      {
        throw new Error( `Tipo de n√≥ n√£o suportado: ${ node.type }` );
      }

      // Executar n√≥
      const result = await executor.call( this, node, workflow, context );

      // Salvar resultado no contexto
      context.results[ node.id ] = result;

      // Se n√£o √© um n√≥ de fim, continuar para pr√≥ximos n√≥s
      if ( node.type !== 'end' )
      {
        const nextNodes = this.getNextNodes( node.id, workflow.edges, workflow.nodes );

        for ( const nextNode of nextNodes )
        {
          await this.executeNode( nextNode, workflow, context );
        }
      }

      return result;

    } catch ( error )
    {
      console.error( `‚ùå Erro na execu√ß√£o do n√≥ ${ node.id }:`, error );
      throw error;
    }
  }

  /**
   * Obter pr√≥ximos n√≥s
   */
  getNextNodes( currentNodeId, edges, nodes )
  {
    const nextNodeIds = edges
      .filter( edge => edge.source === currentNodeId )
      .map( edge => edge.target );

    return nodes.filter( node => nextNodeIds.includes( node.id ) );
  }

  /**
   * Executar n√≥ de in√≠cio
   */
  async executeStartNode( node, workflow, context )
  {
    console.log( `üöÄ Iniciando workflow: ${ workflow.name }` );

    // Inicializar vari√°veis do contexto
    if ( node.data?.variables )
    {
      Object.assign( context.variables, node.data.variables );
    }

    return {
      type: 'start',
      status: 'completed',
      message: 'Workflow iniciado',
      timestamp: new Date().toISOString()
    };
  }

  /**
   * Executar n√≥ de fim
   */
  async executeEndNode( node, workflow, context )
  {
    console.log( `üèÅ Finalizando workflow: ${ workflow.name }` );

    return {
      type: 'end',
      status: 'completed',
      message: 'Workflow finalizado',
      timestamp: new Date().toISOString(),
      finalResults: context.results
    };
  }

  /**
   * Executar n√≥ de condi√ß√£o (MELHORADO)
   */
  async executeConditionNode( node, workflow, context )
  {
    const {
      condition,
      conditions = [], // Para condi√ß√µes m√∫ltiplas
      operator = 'AND', // AND/OR para m√∫ltiplas condi√ß√µes
      trueValue,
      falseValue,
      truePath,
      falsePath
    } = node.data || {};

    if ( !condition && conditions.length === 0 )
    {
      throw new Error( 'Condi√ß√£o n√£o definida' );
    }

    let result;

    // Avaliar condi√ß√£o √∫nica ou m√∫ltiplas
    if ( condition )
    {
      result = this.conditionEngine.evaluateCondition( condition, context );
    } else if ( conditions.length > 0 )
    {
      if ( operator === 'AND' )
      {
        result = conditions.every( cond => this.conditionEngine.evaluateCondition( cond, context ) );
      } else if ( operator === 'OR' )
      {
        result = conditions.some( cond => this.conditionEngine.evaluateCondition( cond, context ) );
      } else
      {
        result = this.conditionEngine.evaluateCondition( conditions[ 0 ], context );
      }
    }

    context.variables[ `${ node.id }_result` ] = result;
    context.variables[ `${ node.id }_value` ] = result ? trueValue : falseValue;

    return {
      type: 'condition',
      status: 'completed',
      result,
      value: result ? trueValue : falseValue,
      nextPath: result ? truePath : falsePath,
      timestamp: new Date().toISOString()
    };
  }

  /**
   * Executar n√≥ de a√ß√£o
   */
  async executeActionNode( node, workflow, context )
  {
    const { action, parameters } = node.data || {};

    if ( !action )
    {
      throw new Error( 'A√ß√£o n√£o definida' );
    }

    if ( context.dryRun )
    {
      return {
        type: 'action',
        status: 'simulated',
        action,
        parameters,
        message: 'A√ß√£o simulada (dry run)',
        timestamp: new Date().toISOString()
      };
    }

    // Executar a√ß√£o espec√≠fica
    let result;
    switch ( action )
    {
      case 'create_record':
        result = await this.createRecord( parameters, context );
        break;
      case 'update_record':
        result = await this.updateRecord( parameters, context );
        break;
      case 'delete_record':
        result = await this.deleteRecord( parameters, context );
        break;
      case 'send_notification':
        result = await this.sendNotification( parameters, context );
        break;
      default:
        throw new Error( `A√ß√£o n√£o suportada: ${ action }` );
    }

    return {
      type: 'action',
      status: 'completed',
      action,
      result,
      timestamp: new Date().toISOString()
    };
  }

  /**
   * Executar n√≥ de email
   */
  async executeEmailNode( node, workflow, context )
  {
    const { to, subject, body, template } = node.data || {};

    if ( !to || !subject )
    {
      throw new Error( 'Destinat√°rio e assunto s√£o obrigat√≥rios' );
    }

    if ( context.dryRun )
    {
      return {
        type: 'email',
        status: 'simulated',
        to,
        subject,
        message: 'Email simulado (dry run)',
        timestamp: new Date().toISOString()
      };
    }

    // Processar template se fornecido
    const processedBody = template ?
      this.processTemplate( template, context.variables ) : body;

    // Enviar email (implementa√ß√£o real seria integrada com servi√ßo de email)
    console.log( `üìß Enviando email para: ${ to }` );
    console.log( `üìß Assunto: ${ subject }` );
    console.log( `üìß Corpo: ${ processedBody }` );

    return {
      type: 'email',
      status: 'completed',
      to,
      subject,
      body: processedBody,
      timestamp: new Date().toISOString()
    };
  }

  /**
   * Executar n√≥ de banco de dados
   */
  async executeDatabaseNode( node, workflow, context )
  {
    const { operation, table, data, conditions } = node.data || {};

    if ( !operation || !table )
    {
      throw new Error( 'Opera√ß√£o e tabela s√£o obrigat√≥rias' );
    }

    if ( context.dryRun )
    {
      return {
        type: 'database',
        status: 'simulated',
        operation,
        table,
        message: 'Opera√ß√£o de banco simulada (dry run)',
        timestamp: new Date().toISOString()
      };
    }

    let result;
    switch ( operation )
    {
      case 'select':
        result = await this.db.query( `SELECT * FROM ${ table } WHERE ${ conditions || '1=1' }` );
        break;
      case 'insert':
        result = await this.db.query( `INSERT INTO ${ table } SET ?`, [ data ] );
        break;
      case 'update':
        result = await this.db.query( `UPDATE ${ table } SET ? WHERE ${ conditions }`, [ data ] );
        break;
      case 'delete':
        result = await this.db.query( `DELETE FROM ${ table } WHERE ${ conditions }` );
        break;
      default:
        throw new Error( `Opera√ß√£o n√£o suportada: ${ operation }` );
    }

    return {
      type: 'database',
      status: 'completed',
      operation,
      table,
      result,
      timestamp: new Date().toISOString()
    };
  }

  /**
   * Executar n√≥ de processamento qu√¢ntico
   */
  async executeQuantumProcessNode( node, workflow, context )
  {
    const { algorithm, parameters, complexity = 2 } = node.data || {};

    if ( !algorithm )
    {
      throw new Error( 'Algoritmo qu√¢ntico n√£o especificado' );
    }

    if ( context.dryRun )
    {
      return {
        type: 'quantum_process',
        status: 'simulated',
        algorithm,
        message: 'Processamento qu√¢ntico simulado (dry run)',
        timestamp: new Date().toISOString()
      };
    }

    const result = await this.quantumProcessor.processOperation( {
      type: algorithm,
      data: parameters,
      complexity,
      userId: context.userId
    } );

    return {
      type: 'quantum_process',
      status: result.success ? 'completed' : 'failed',
      algorithm,
      result,
      timestamp: new Date().toISOString()
    };
  }

  /**
   * Executar n√≥ de an√°lise MILA
   */
  async executeMilaAnalyzeNode( node, workflow, context )
  {
    const { analysisType, data, parameters } = node.data || {};

    if ( !analysisType )
    {
      throw new Error( 'Tipo de an√°lise n√£o especificado' );
    }

    if ( context.dryRun )
    {
      return {
        type: 'mila_analyze',
        status: 'simulated',
        analysisType,
        message: 'An√°lise MILA simulada (dry run)',
        timestamp: new Date().toISOString()
      };
    }

    const result = await this.milaService.processAnalysis( {
      type: analysisType,
      data,
      parameters,
      userId: context.userId
    } );

    return {
      type: 'mila_analyze',
      status: result.success ? 'completed' : 'failed',
      analysisType,
      result,
      timestamp: new Date().toISOString()
    };
  }

  /**
   * Detectar ciclos no workflow
   */
  detectCycles( nodes, edges )
  {
    const visited = new Set();
    const recursionStack = new Set();

    const hasCycleDFS = ( nodeId ) =>
    {
      if ( recursionStack.has( nodeId ) )
      {
        return true;
      }

      if ( visited.has( nodeId ) )
      {
        return false;
      }

      visited.add( nodeId );
      recursionStack.add( nodeId );

      const neighbors = edges
        .filter( edge => edge.source === nodeId )
        .map( edge => edge.target );

      for ( const neighbor of neighbors )
      {
        if ( hasCycleDFS( neighbor ) )
        {
          return true;
        }
      }

      recursionStack.delete( nodeId );
      return false;
    };

    for ( const node of nodes )
    {
      if ( hasCycleDFS( node.id ) )
      {
        return true;
      }
    }

    return false;
  }

  /**
   * Encontrar n√≥s n√£o alcan√ß√°veis
   */
  findUnreachableNodes( nodes, edges )
  {
    const startNodes = nodes.filter( node => node.type === 'start' );
    const reachable = new Set();

    const markReachable = ( nodeId ) =>
    {
      if ( reachable.has( nodeId ) )
      {
        return;
      }

      reachable.add( nodeId );

      const neighbors = edges
        .filter( edge => edge.source === nodeId )
        .map( edge => edge.target );

      for ( const neighbor of neighbors )
      {
        markReachable( neighbor );
      }
    };

    // Marcar todos os n√≥s alcan√ß√°veis a partir dos n√≥s de in√≠cio
    for ( const startNode of startNodes )
    {
      markReachable( startNode.id );
    }

    // Encontrar n√≥s n√£o alcan√ß√°veis
    return nodes
      .filter( node => !reachable.has( node.id ) )
      .map( node => node.id );
  }

  /**
   * Avaliar condi√ß√£o
   */
  evaluateCondition( condition, context )
  {
    try
    {
      // Implementa√ß√£o simplificada - em produ√ß√£o seria mais robusta
      const variables = context.variables;

      // Substituir vari√°veis na condi√ß√£o
      let processedCondition = condition;
      Object.keys( variables ).forEach( key =>
      {
        const regex = new RegExp( `\\$\\{${ key }\\}`, 'g' );
        processedCondition = processedCondition.replace( regex, variables[ key ] );
      } );

      // Avaliar condi√ß√£o (cuidado com eval em produ√ß√£o!)
      return eval( processedCondition );

    } catch ( error )
    {
      console.error( '‚ùå Erro na avalia√ß√£o da condi√ß√£o:', error );
      return false;
    }
  }

  /**
   * Processar template
   */
  processTemplate( template, variables )
  {
    let processed = template;

    Object.keys( variables ).forEach( key =>
    {
      const regex = new RegExp( `\\$\\{${ key }\\}`, 'g' );
      processed = processed.replace( regex, variables[ key ] );
    } );

    return processed;
  }
}

module.exports = WorkflowService;
