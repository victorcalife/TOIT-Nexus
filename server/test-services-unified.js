/**
 * TESTE DOS SERVI√áOS UNIFICADOS
 * Valida camada de servi√ßos e interfaces p√∫blicas
 * 100% JavaScript - SEM TYPESCRIPT
 */

class ServicesTestSuite {
  constructor() {
    this.passed = 0;
    this.failed = 0;
  }

  /**
   * EXECUTAR TESTE
   */
  async runTest(name, testFn) {
    try {
      console.log(`üß™ [TEST] Executando: ${name}`);
      await testFn();
      console.log(`‚úÖ [TEST] PASSOU: ${name}`);
      this.passed++;
    } catch (error) {
      console.error(`‚ùå [TEST] FALHOU: ${name} - ${error.message}`);
      this.failed++;
    }
  }

  /**
   * TESTE DE IMPORTA√á√ÉO DOS SERVI√áOS
   */
  async testServicesImport() {
    try {
      const services = require('./services-unified');
      
      if (!services) {
        throw new Error('Servi√ßos n√£o puderam ser importados');
      }

      // Verificar se as classes principais existem
      const requiredClasses = [
        'BaseService',
        'UserService', 
        'TenantService',
        'ClientService',
        'WorkflowService'
      ];

      for (const className of requiredClasses) {
        if (!services[className]) {
          throw new Error(`Classe ${className} n√£o encontrada`);
        }
      }

      // Verificar se as inst√¢ncias existem
      const requiredInstances = [
        'userService',
        'tenantService', 
        'clientService',
        'workflowService'
      ];

      for (const instanceName of requiredInstances) {
        if (!services[instanceName]) {
          throw new Error(`Inst√¢ncia ${instanceName} n√£o encontrada`);
        }
      }

      console.log(`üì¶ [TEST] Servi√ßos importados: ${Object.keys(services).length} exports`);
    } catch (error) {
      throw new Error(`Erro na importa√ß√£o: ${error.message}`);
    }
  }

  /**
   * TESTE DA CLASSE BASE
   */
  async testBaseService() {
    try {
      const { BaseService } = require('./services-unified');
      
      // Criar inst√¢ncia mock
      const mockService = new BaseService('test_table');
      
      if (!mockService.tableName || mockService.tableName !== 'test_table') {
        throw new Error('BaseService n√£o inicializou corretamente');
      }

      // Verificar se m√©todos b√°sicos existem
      const requiredMethods = [
        'findById',
        'list', 
        'create',
        'update',
        'delete'
      ];

      for (const method of requiredMethods) {
        if (typeof mockService[method] !== 'function') {
          throw new Error(`M√©todo ${method} n√£o encontrado na BaseService`);
        }
      }

      console.log(`üèóÔ∏è [TEST] BaseService com ${requiredMethods.length} m√©todos`);
    } catch (error) {
      throw new Error(`Erro na BaseService: ${error.message}`);
    }
  }

  /**
   * TESTE DO USER SERVICE
   */
  async testUserService() {
    try {
      const { UserService, userService } = require('./services-unified');
      
      // Verificar se √© inst√¢ncia da classe correta
      if (!(userService instanceof UserService)) {
        throw new Error('userService n√£o √© inst√¢ncia de UserService');
      }

      // Verificar m√©todos espec√≠ficos do UserService
      const specificMethods = [
        'findByCPF',
        'findByEmail',
        'createUser',
        'updateLastLogin',
        'getUsersByTenant'
      ];

      for (const method of specificMethods) {
        if (typeof userService[method] !== 'function') {
          throw new Error(`M√©todo ${method} n√£o encontrado no UserService`);
        }
      }

      // Verificar se herda da BaseService
      const baseMethods = ['findById', 'list', 'create', 'update', 'delete'];
      for (const method of baseMethods) {
        if (typeof userService[method] !== 'function') {
          throw new Error(`M√©todo herdado ${method} n√£o encontrado`);
        }
      }

      console.log(`üë§ [TEST] UserService com ${specificMethods.length} m√©todos espec√≠ficos`);
    } catch (error) {
      throw new Error(`Erro no UserService: ${error.message}`);
    }
  }

  /**
   * TESTE DO TENANT SERVICE
   */
  async testTenantService() {
    try {
      const { TenantService, tenantService } = require('./services-unified');
      
      if (!(tenantService instanceof TenantService)) {
        throw new Error('tenantService n√£o √© inst√¢ncia de TenantService');
      }

      const specificMethods = [
        'findBySlug',
        'findByDomain',
        'getActiveTenants'
      ];

      for (const method of specificMethods) {
        if (typeof tenantService[method] !== 'function') {
          throw new Error(`M√©todo ${method} n√£o encontrado no TenantService`);
        }
      }

      console.log(`üè¢ [TEST] TenantService com ${specificMethods.length} m√©todos espec√≠ficos`);
    } catch (error) {
      throw new Error(`Erro no TenantService: ${error.message}`);
    }
  }

  /**
   * TESTE DO CLIENT SERVICE
   */
  async testClientService() {
    try {
      const { ClientService, clientService } = require('./services-unified');
      
      if (!(clientService instanceof ClientService)) {
        throw new Error('clientService n√£o √© inst√¢ncia de ClientService');
      }

      const specificMethods = [
        'getClientsByTenant',
        'searchClients'
      ];

      for (const method of specificMethods) {
        if (typeof clientService[method] !== 'function') {
          throw new Error(`M√©todo ${method} n√£o encontrado no ClientService`);
        }
      }

      console.log(`üë• [TEST] ClientService com ${specificMethods.length} m√©todos espec√≠ficos`);
    } catch (error) {
      throw new Error(`Erro no ClientService: ${error.message}`);
    }
  }

  /**
   * TESTE DO WORKFLOW SERVICE
   */
  async testWorkflowService() {
    try {
      const { WorkflowService, workflowService } = require('./services-unified');
      
      if (!(workflowService instanceof WorkflowService)) {
        throw new Error('workflowService n√£o √© inst√¢ncia de WorkflowService');
      }

      const specificMethods = [
        'getWorkflowsByTenant',
        'executeWorkflow'
      ];

      for (const method of specificMethods) {
        if (typeof workflowService[method] !== 'function') {
          throw new Error(`M√©todo ${method} n√£o encontrado no WorkflowService`);
        }
      }

      console.log(`‚öôÔ∏è [TEST] WorkflowService com ${specificMethods.length} m√©todos espec√≠ficos`);
    } catch (error) {
      throw new Error(`Erro no WorkflowService: ${error.message}`);
    }
  }

  /**
   * TESTE DE INTERFACES P√öBLICAS
   */
  async testPublicInterfaces() {
    try {
      const services = require('./services-unified');
      
      // Testar se todas as interfaces p√∫blicas est√£o dispon√≠veis
      const publicInterfaces = [
        // Classes
        'BaseService',
        'UserService',
        'TenantService', 
        'ClientService',
        'WorkflowService',
        
        // Inst√¢ncias
        'userService',
        'tenantService',
        'clientService', 
        'workflowService'
      ];

      for (const interfaceName of publicInterfaces) {
        if (!services[interfaceName]) {
          throw new Error(`Interface p√∫blica ${interfaceName} n√£o dispon√≠vel`);
        }
      }

      console.log(`üîå [TEST] Interfaces p√∫blicas: ${publicInterfaces.length} dispon√≠veis`);
    } catch (error) {
      throw new Error(`Erro nas interfaces: ${error.message}`);
    }
  }

  /**
   * TESTE DE HERAN√áA
   */
  async testInheritance() {
    try {
      const { BaseService, UserService, userService } = require('./services-unified');
      
      // Verificar se UserService herda de BaseService
      if (!(UserService.prototype instanceof BaseService)) {
        throw new Error('UserService n√£o herda de BaseService');
      }

      // Verificar se inst√¢ncia tem m√©todos da classe pai
      const baseMethods = ['findById', 'list', 'create', 'update', 'delete'];
      for (const method of baseMethods) {
        if (typeof userService[method] !== 'function') {
          throw new Error(`M√©todo herdado ${method} n√£o dispon√≠vel`);
        }
      }

      console.log(`üß¨ [TEST] Heran√ßa funcionando: ${baseMethods.length} m√©todos herdados`);
    } catch (error) {
      throw new Error(`Erro na heran√ßa: ${error.message}`);
    }
  }

  /**
   * TESTE DE CONFIGURA√á√ÉO DE TABELAS
   */
  async testTableConfiguration() {
    try {
      const { userService, tenantService, clientService } = require('./services-unified');
      
      // Verificar se cada servi√ßo tem sua tabela configurada
      const serviceTableMap = {
        userService: 'users',
        tenantService: 'tenants', 
        clientService: 'clients'
      };

      for (const [serviceName, expectedTable] of Object.entries(serviceTableMap)) {
        const service = eval(serviceName);
        if (service.tableName !== expectedTable) {
          throw new Error(`${serviceName} n√£o configurado para tabela ${expectedTable}`);
        }
      }

      console.log(`üóÑÔ∏è [TEST] Configura√ß√£o de tabelas: ${Object.keys(serviceTableMap).length} servi√ßos`);
    } catch (error) {
      throw new Error(`Erro na configura√ß√£o: ${error.message}`);
    }
  }

  /**
   * TESTE DE MOCK DE OPERA√á√ïES
   */
  async testMockOperations() {
    try {
      const { userService } = require('./services-unified');
      
      // Mock do banco de dados para teste
      const originalDb = userService.db;
      userService.db = {
        select: () => ({
          from: () => ({
            where: () => ({ limit: () => [{ id: 'test-user', cpf: '12345678901' }] })
          })
        })
      };

      // Testar opera√ß√£o mock
      try {
        // Esta opera√ß√£o deveria funcionar com o mock
        const mockResult = await userService.findByCPF('12345678901');
        // Restaurar DB original
        userService.db = originalDb;
        
        console.log(`üé≠ [TEST] Opera√ß√µes mock funcionando`);
      } catch (mockError) {
        // Restaurar DB original mesmo em caso de erro
        userService.db = originalDb;
        throw mockError;
      }
    } catch (error) {
      throw new Error(`Erro nas opera√ß√µes mock: ${error.message}`);
    }
  }

  /**
   * EXECUTAR TODOS OS TESTES
   */
  async runAllTests() {
    console.log('üöÄ [TEST] Iniciando testes dos servi√ßos unificados...\n');

    await this.runTest('Importa√ß√£o dos Servi√ßos', () => this.testServicesImport());
    await this.runTest('Classe Base', () => this.testBaseService());
    await this.runTest('User Service', () => this.testUserService());
    await this.runTest('Tenant Service', () => this.testTenantService());
    await this.runTest('Client Service', () => this.testClientService());
    await this.runTest('Workflow Service', () => this.testWorkflowService());
    await this.runTest('Interfaces P√∫blicas', () => this.testPublicInterfaces());
    await this.runTest('Sistema de Heran√ßa', () => this.testInheritance());
    await this.runTest('Configura√ß√£o de Tabelas', () => this.testTableConfiguration());
    await this.runTest('Opera√ß√µes Mock', () => this.testMockOperations());

    console.log('\nüìä [TEST] Resultados dos testes:');
    console.log(`‚úÖ Passou: ${this.passed}`);
    console.log(`‚ùå Falhou: ${this.failed}`);
    console.log(`üìà Taxa de sucesso: ${Math.round((this.passed / (this.passed + this.failed)) * 100)}%`);

    if (this.failed === 0) {
      console.log('\nüéâ [TEST] Todos os testes passaram! Servi√ßos unificados funcionando perfeitamente.');
      return true;
    } else {
      console.log('\n‚ö†Ô∏è [TEST] Alguns testes falharam. Verifique os erros acima.');
      return false;
    }
  }
}

// Executar testes se chamado diretamente
if (require.main === module) {
  const testSuite = new ServicesTestSuite();
  testSuite.runAllTests().then(success => {
    process.exit(success ? 0 : 1);
  }).catch(error => {
    console.error('üí• [TEST] Erro cr√≠tico nos testes:', error);
    process.exit(1);
  });
}

module.exports = ServicesTestSuite;
